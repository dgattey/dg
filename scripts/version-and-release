#!/usr/bin/env node
const fs = require('fs');
const path = require('path');
const { execSync } = require('child_process');
const https = require('https');

// DESCRIPTION: Manage version tags and Github releases

const PACKAGE_JSON = path.join(__dirname, '..', 'package.json');

// Read version from package.json
function readVersion() {
  const pkg = JSON.parse(fs.readFileSync(PACKAGE_JSON, 'utf8'));
  console.log(`VERSION=${pkg.version}`);
}

// Parse PR body for release type (Major/Minor/Patch checkboxes)
function prInfo(eventPath) {
  const event = JSON.parse(fs.readFileSync(eventPath, 'utf8'));
  const body = event.pull_request?.body || '';
  
  // Check which release type checkbox is checked (Major > Minor > Patch)
  const releaseType = /- \[x\]\s*Major/i.test(body) ? 'major'
    : /- \[x\]\s*Minor/i.test(body) ? 'minor'
    : 'patch';
  
  console.log(`RELEASE_TYPE=${releaseType}`);
}

function computeNext(baseVersion, releaseType) {
  const normalizedVersion = baseVersion.split('-', 1)[0];
  const parts = normalizedVersion.split('.').map(Number);
  if (parts.length !== 3 || parts.some(isNaN)) {
    throw new Error(`Invalid version: ${baseVersion}`);
  }

  let [major, minor, patch] = parts;

  if (releaseType === 'major') { major++; minor = 0; patch = 0; }
  else if (releaseType === 'minor') { minor++; patch = 0; }
  else { patch++; }

  return `${major}.${minor}.${patch}`;
}

function logVersionChange(baseVersion, newVersion) {
  console.log(`VERSION_FROM=${baseVersion}`);
  console.log(`VERSION_TO=${newVersion}`);
}

// Bump version in package.json
function bump(baseVersion, releaseType) {
  const newVersion = computeNext(baseVersion, releaseType);
  const pkg = JSON.parse(fs.readFileSync(PACKAGE_JSON, 'utf8'));
  pkg.version = newVersion;
  fs.writeFileSync(PACKAGE_JSON, JSON.stringify(pkg, null, 2) + '\n', 'utf8');

  logVersionChange(baseVersion, newVersion);
}

function getLatestTagVersion() {
  try {
    const output = execSync('git tag --list --sort=-v:refname', {
      encoding: 'utf8',
      stdio: ['ignore', 'pipe', 'ignore'],
    });
    const tags = output.split('\n').map((tag) => tag.trim()).filter(Boolean);
    const match = tags.find((tag) => /^v?\d+\.\d+\.\d+(?:-[0-9A-Za-z.-]+)?$/.test(tag));
    return match ? match.replace(/^v/, '') : null;
  } catch {
    return null;
  }
}

function targetVersionFromTags(currentVersion, releaseType) {
  const baseVersion = getLatestTagVersion() ?? currentVersion;
  const newVersion = computeNext(baseVersion, releaseType);
  console.log(`BASE_VERSION_USED=${baseVersion}`);
  logVersionChange(baseVersion, newVersion);
}

// Extract "What changed?" section from PR body
function extractNotes(eventPath) {
  const event = JSON.parse(fs.readFileSync(eventPath, 'utf8'));
  const body = event.pull_request?.body || '';
  
  const lines = body.split('\n');
  let inSection = false;
  const notes = [];
  
  for (const line of lines) {
    if (/^#\s*What changed\?/i.test(line)) {
      inSection = true;
    } else if (inSection && (/^#\s*Release info/i.test(line) || /^-+\s*$/.test(line))) {
      break;
    } else if (inSection) {
      notes.push(line);
    }
  }
  
  console.log(notes.join('\n').trim());
}

function getRepoInfo(eventPath) {
  const event = JSON.parse(fs.readFileSync(eventPath, 'utf8'));
  const owner = event.repository?.owner?.login;
  const repo = event.repository?.name;
  const issueNumber = event.pull_request?.number;

  if (!owner || !repo || !issueNumber) {
    throw new Error('Missing repository or pull request info in event payload');
  }

  return { owner, repo, issueNumber };
}

function requestGithub({ token, method, path: requestPath, body }) {
  return new Promise((resolve, reject) => {
    const options = {
      method,
      hostname: 'api.github.com',
      path: requestPath,
      headers: {
        Authorization: `Bearer ${token}`,
        Accept: 'application/vnd.github+json',
        'User-Agent': 'version-and-release-script',
      },
    };

    const req = https.request(options, (res) => {
      let data = '';
      res.setEncoding('utf8');
      res.on('data', (chunk) => { data += chunk; });
      res.on('end', () => {
        if (res.statusCode && res.statusCode >= 200 && res.statusCode < 300) {
          resolve(data ? JSON.parse(data) : null);
          return;
        }
        reject(new Error(`GitHub API error ${res.statusCode}: ${data}`));
      });
    });

    req.on('error', (error) => {
      reject(error);
    });

    if (body) {
      req.setHeader('Content-Type', 'application/json');
      req.write(JSON.stringify(body));
    }

    req.end();
  });
}

async function upsertPrComment(eventPath, version, state, releaseUrl) {
  const token = process.env.GITHUB_TOKEN;
  if (!token) throw new Error('GITHUB_TOKEN is required to update PR comments');

  const { owner, repo, issueNumber } = getRepoInfo(eventPath);
  const marker = '<!-- release-bot-version-comment -->';
  const isReleased = state === 'released';

  if (!version) throw new Error('Version is required to update PR comment');
  if (isReleased && !releaseUrl) {
    throw new Error('Release URL is required for released comment');
  }

  const body = isReleased
    ? `${marker}\nðŸŽ‰ This PR is included in version ${version} ðŸŽ‰\n\n` +
      `The release is available on [GitHub release](${releaseUrl})`
    : `${marker}\nðŸŽ‰ This PR will be included in version ${version} ðŸŽ‰`;

  const comments = await requestGithub({
    token,
    method: 'GET',
    path: `/repos/${owner}/${repo}/issues/${issueNumber}/comments?per_page=100`,
  });

  const existing = Array.isArray(comments)
    ? comments.find((comment) => comment.body && comment.body.includes(marker))
    : null;

  if (existing) {
    await requestGithub({
      token,
      method: 'PATCH',
      path: `/repos/${owner}/${repo}/issues/comments/${existing.id}`,
      body: { body },
    });
  } else {
    await requestGithub({
      token,
      method: 'POST',
      path: `/repos/${owner}/${repo}/issues/${issueNumber}/comments`,
      body: { body },
    });
  }
}

// Main
const [,, command, ...args] = process.argv;

if (!command || command === '--help' || command === '-h') {
  console.log('Usage: scripts/version-and-release <command> [args...]');
  console.log('');
  console.log('Commands:');
  console.log('  read                                  Read version from package.json');
  console.log('  pr-info <event-path>                  Parse release type from PR event');
  console.log('  bump <version> <major|minor|patch>    Compute and write next version');
  console.log('  target-from-tags <current> <type>     Compute target from repo tags');
  console.log('  extract-notes <event-path>            Extract release notes from PR');
  console.log('  pr-comment <event> <version> <state>  Upsert PR version comment');
  console.log('                                         state: will-be|released');
  console.log('                                         set RELEASE_URL for released');
  process.exit(0);
}

async function main() {
  if (command === 'read') readVersion();
  else if (command === 'pr-info') prInfo(args[0]);
  else if (command === 'bump') bump(args[0], args[1]);
  else if (command === 'target-from-tags') targetVersionFromTags(args[0], args[1]);
  else if (command === 'extract-notes') extractNotes(args[0]);
  else if (command === 'pr-comment') {
    const [eventPath, version, state] = args;
    const releaseUrl = process.env.RELEASE_URL;
    if (state !== 'will-be' && state !== 'released') {
      throw new Error('State must be "will-be" or "released"');
    }
    await upsertPrComment(eventPath, version, state, releaseUrl);
  } else {
    throw new Error(`Unknown command: ${command}`);
  }
}

main().catch((error) => {
  console.error(`Error: ${error.message}`);
  process.exit(1);
});
