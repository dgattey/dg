#!/usr/bin/env bash
set -euo pipefail

ROOT="$(cd "$(dirname "${BASH_SOURCE[0]}")/.." && pwd)"
OUTPUT_FILE="${ROOT}/.env"
KEYS_FILE="${ROOT}/config/env.secrets.keys"

# Skip if 1Password CLI is not available (e.g., CI, Vercel)
if ! command -v op &>/dev/null; then
  echo "1Password CLI not found, skipping .env generation" >&2
  exit 0
fi

# Read keys from the keys file (skip comments and blank lines)
keys=()
while read -r key; do
  [[ -z "$key" || "$key" == \#* ]] && continue
  keys+=("$key")
done < "$KEYS_FILE"

# Get expected output keys
expected_keys=$(printf '%s\n' "${keys[@]}" | sort -u)

# Check if .env exists with correct keys
if [[ -f "$OUTPUT_FILE" ]]; then
  existing_keys=$(grep -v '^#' "$OUTPUT_FILE" | grep -v '^$' | cut -d= -f1 | sort)

  if [[ "$expected_keys" == "$existing_keys" ]]; then
    echo ".env already exists with correct keys" >&2
    exit 0
  fi

  echo ".env keys mismatch, regenerating..." >&2
fi

# Remove old .env if regenerating
rm -f "$OUTPUT_FILE"

# Check 1Password auth
export OP_ACCOUNT="my.1password.com"
if ! op whoami >/dev/null 2>&1; then
  echo "Signing in to 1Password..." >&2
  op signin --account "$OP_ACCOUNT" || {
    echo "1Password sign-in failed. Enable: 1Password > Settings > Developer > Integrate with 1Password CLI" >&2
    exit 1
  }
fi

# Fetch secrets in parallel
echo "Fetching secrets from 1Password..." >&2
TMP_DIR="$(mktemp -d)"
trap 'rm -rf "$TMP_DIR"' EXIT

for key in "${keys[@]}"; do
  (op read "op://dg/${key}/value" > "${TMP_DIR}/${key}" 2>&1) &
done
wait

# Write secrets to .env
for file in "$TMP_DIR"/*; do
  [[ -f "$file" ]] || continue
  key="$(basename "$file")"
  value="$(<"$file")"

  if [[ -z "$value" || "$value" == *"ERROR"* ]]; then
    echo "Failed to read $key from 1Password" >&2
    exit 1
  fi

  # Escape for .env format
  value="${value//\\/\\\\}"
  value="${value//\"/\\\"}"
  value="${value//$'\n'/\\n}"

  echo "${key}=\"${value}\"" >> "$OUTPUT_FILE"
done

echo "Generated .env"
